# Gráficos com `ggplot2`

<!-- #USAR DADOS DELES (ibama OU DO CENSO ESCOLAR) -->

<!-- # SCATTER/POINT, COL, BAR(HIST), LINE, BARRAS JUSTAPOSTAS -->
<!-- # COMECAR PELOSN GEOMS E IR alterando aesthetics.. -->
<!-- # alterações de legendas e themes -->
<!-- # terminar no facetting -->

Nesta seção veremos como fazer gráficos sofisticados no **R**. Serão apenas noções básicas, uma vez que a `ggplot2` propicia um controle total de quase todos os aspectos de um gráfico ao usuário. No entanto, já serão ferramentas sufcientes para confecionar e personalizar diversos gráficos no **R**. A quantidade de tipos de gráficos que podemos fazer com **ggplot2** é imensurável. A ideia é enterdermos os conceitos básicos e estruturais do pacote para depois caminharmos com nossas próprias pernas.

## Introdução

O pacote `ggplot2` cria gráficos utilizando camadas de atributos, utilizando a chamada **gramática de gráficos**. Esta gramática permite construir gráficos componente por componente ao invés de termos que editar gráficos "pré-fabricados" como ocorre no `base R` e em todas as outras bibliotecas de linguagens usadas para _Data Science_, como _matplotlib_ e _seaborn_ de _Python_, por exemplo.

Nós não precisamos conhecer a gramática para começar a produzir gráficos com **ggplot2**. Todavia, ao compreendermos a estrutura da gramática de gráficos, podemos:

- construir gráficos a partir de conceitos (do que desejamos fazer) ao invés de termos que lembrar comandos e opções;

- conceber novos e melhorados gráficos.

O `ggplot2`, embora tenha surgido antes do _tidyverse_, também é um dos pacotes que do _core_ deste _meta-packge_. Ele foi escrito por Hadley Wickham, o qual publicou o livro intitulado _"ggplot2 Elegant Graphics for Data Analysis"_. O sucesso de `ggplot2` é tão expressivo que foram feitos _APIs (Application Programming Interface)_ para que as funcionalidades do pacote pudessem ser empregadas em outra s linguagens, como Python por exemplo.

## A gramática de gráficos

A gramática de gráficos foi um conceito desenvolvido por Leland Wilkinson em 1999 e publicado por ele em _The Grammar of Graphics_ em 2005. Essa gramática define regras para estruturar elementos matemáticos e estéticos (_aesthetics_) em um gráfico propriamente dito. `ggplot2` é escrito sob as regras desta gramática.


### Estrutura da gramática de gráficos no `ggplot2`:

- **data**
  + dados que contém as variáveis a serem plotadas ;
  + variáveis a serem retratadas no gráfico;
  + variáveis a serem mapeadas para os *aesthetics* (elementos perceptíveis) do gráfico;

- **Geoms** (formas geométricas)
  + objetos e formas do gráfico (barras, pontos, linhas, etc)

- **Stats**
  + transformações estatísticas , geralmente para sumarizar dados (média, variância, mediana, etc)

- **Scales**
  + define quais elementos estéticos (_aesthetics_) do gráfico serão mapeados para as variáveis (ex: que cores serão mapeadas a quais valores)

- **Coordinate Systems**
  + define como os dados serão mapeados para o plano/área do gráfico (Cartesiano, Polar, etc)

- **Facetting**
  + divide os dados em subconjuntos para criar multiplas variações do mesmo gráfico (ex: gráficos em painel)

Todos esses elementos são tratados como _layers_ e podem ser adiconadas a parte principal do gráfico utilizando-se o sinal `+`.

Neste curso, veremos de forma mais detalhada os elementos *data*, *aesthetics*, *stats* e *facetting* e o que significa cada um desses elementos na estrutura da gramática de gráficos. Vamos utilizar dois _datasets_: o de produção madeireira disponibilizado pelo IBAMA e um novo, contendo uma série histórica modificada do censo escolar agregado do Instituto de Pesquisas Educacionais Anísio Teixeira (INEP). Os dados contém o número de estudantes por série de ensino, escola, munícipio e outras variáveis para o período compreendido entre 2007 e 2019, apenas para os estados do Espírito Santo, Mato Grosso do Sul e Roraima.

Como o arquivo do Censo Escolar está no formato `.csv` pt-br (separado por `;`), podemos utilizar a função `read_csv2()` do pacote `readr`.

```{r, message=FALSE}
library(readr) # para ler os dados
library(magrittr) # vamos usar pipe %>%
library(ggplot2) # para fazer os gráficos
# leitura
tb_censo_escolar <- read_csv2(file="https://raw.githubusercontent.com/allanvc/book_IADR-T/master/datasets/tab_censo_sample_ES_MS_RR.csv")
```

Caso, você não possua mais a `tb_ibama2` em sua sessão do R, carregue a tabela original e fça novamente as alterações que fizemos nas seções anteriores

```{r, message=FALSE, eval=FALSE}
library(dplyr)
tb_ibama <- read_csv(file="https://raw.githubusercontent.com/allanvc/book_IADR-T/master/datasets/PA%20GF%202017%20jan-jun_editada.csv",
                     col_types = cols(
                       X1 = col_double(),
                       TIPO_GF = col_character(),
                       STATUS_GF = col_character(),
                       UF_REMETENTE = col_character(),
                       MUNICÍPIO_REMETENTE = col_character(),
                       TIPO_DESTINO = col_character(),
                       CEPROF_DESTINATÁRIO = col_character(),
                       UF_DESTINATÁRIO = col_character(),
                       MUNICÍPIO_DESTINATÁRIO = col_character(),
                       N_AUTORIZAÇÃO = col_character(),
                       PROCESSO = col_character(),
                       EMISSAO = col_integer(),
                       NOME_CIENTÍFICO = col_character(),
                       PRODUTO = col_character(),
                       VOLUME = col_double(),
                       UNID = col_character(),
                       PRECO_TOTAL = col_double()
                       )
                     )
tb_ibama$STATUS_GF[1:50000] <- rep("NÃO VERIFICADO", 50000)
tb_ibama2 <- mutate(tb_ibama,
  preco_unidade = PRECO_TOTAL / VOLUME,
  preco_unidade_vezes_1000 = preco_unidade * 1000
)
```

## Data (Dados)

Os dados utilizados com as funções de `ggplot2` **DEVEM** ser armazenados como um tibble ou dataframe. Há possibilidade, inclusive, de se usar mais de um dataframe em um gráfico. A recomendação é que se defina e se certifique acerca dos tipos das variáveis (_numeric_, _factor_, etc) antes de começar a construir um gráfico

## A função `ggplot()`

Os dados que serão usados para plotagem serão especificados dentro da função `ggplot()`. Note que é **ggplot()** e não **ggplot2()**. O nosso dataframe/tibble sempre será  primeiro argumento desta função.

Um outro argumento a ser passado para a função `ggplot()` são os _aesthetics_, utilizando a função auxiliar `aes()` que mapeia as variáveis dos dados para os elementos gráficos perceptíveis (estéticos), como a posição nos eixos dos gráficos, a definição de cores por categorias, etc.

Qualquer função subsequente vai herdar os dados e os _aesthetics_ de `ggplot()`, a não ser que estes parâmetros sejam sobrescritos em outra camada. Para encadear outras funções a função `ggplot()`, usamos sempre `+`.

## Aesthetics (elementos estéticos dos gráficos)

Variáveis são mapeadas para os **aesthetics**, o que significa que são traduzidas para os elementos estéticos do gráfico. A função `aes()` é quem faz esse mapeamento. Ela também pode ser especificada dentro de outras camadas que compões o gráfico, como _geoms_ e _stats_, por exemplo . Os **aesthetics** mais utilizados são:

- `x` - posição no eixo x;

- `y` - posição no eixo y;

- `color` ou `colour` - "cor de fora" ou do contorno do objeto;

- `fill` - "cor de dentro" do objeto;

- `alpha` - nível transparência do gráfico;

- `shape` - forma dos marcadores (pontos, triângilos, cruz, etc);

- `size` - tamanho (do raio) dos objetos.


## Exemplos para _aesthetics_


Para fazermos um gráfico, primeiro precisamos indicar os dados e fazer o mapeamento das variáveis aos **aesthetics**. Isso reserva uma área de gráfico a ser utilizada.

```{r, fig.align="center"}
options(scipen= 999) # para enalizar a exibição em notação exponencial
# ggplot(data=tb_ibama2, mapping = aes(x=VOLUME, y=PRECO_TOTAL))
# OU
tb_ibama2 %>%
  ggplot(data=tb_ibama2, mapping = aes(x=VOLUME, y=PRECO_TOTAL))
```

Vejamos um primeiro exemplo para o cruzamento entre _VOLUME_ vs _PRECO_TOTAL_.

```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL))+
  geom_point()
```


Note que não houve a necessidade de re-especificar os argumentos `data` e `aes()` para a função `geom_point()`.

Poderíamos melhorar nosso gráfico adicionando cores dentro de `aes()`. Isso acrescentaria mais informação. Poderíamos atribuir cores diferentes para cada tipo de destino das toras de madeira:

```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL))+
  geom_point(aes(color=TIPO_DESTINO))
# ou
# tb_ibama2 %>%
#   ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL, color=TIPO_DESTINO))+
#   geom_point()
```

Podemos atribuir diferentes intensidades aos pontos, dependendo do valor de uma terceira variável (de preferência contínua entre 0 e 1), utilizando o argumento `alpha`. Como no nosso dataset do IBAMA, não temos tal variável, vamos criar uma variável contínua por meio da simulação de valores dentro de uma distribuição de probabilidade Normal ($N(0,1)$):

```{r, fig.align="center"}
# simulando valores
tb_ibama2 <- tb_ibama2 %>%
  mutate(quant_sim = rnorm(n()),
         prob_sim = pnorm(quant_sim)
  )
tb_ibama2 %>%
  ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL, alpha=prob_sim))+
  geom_point()
```

Neste nosso caso, esse gráfico não é muito útil porque temos vários pontos sobrepostos e isto dificulta a percepção de como as cores estão variando. No entanto, serve para ilustrar essa possibilidade com `ggplot2`.

Uma melhor forma de demonstrar os diferentes tipos de destino seria utilizar diferentes formas (argumento `shape`):

```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL, shape=TIPO_DESTINO))+
  geom_point()
```


### Mapping vs Setting aesthetics

Nos exemplos anteriores, poderíamos optar por usar apenas uma única cor ou um único shape que não fosse o padrão de "bolinha" na cor preta. O que deveríamos fazer então, ao invés de **mapear** variáveis para **aesthetic**, é **setar** a **aesthetic** contante.

Quando vamos mapear um **aesthetic**, as variáveis são passadas **dentro** de `aes()`; ao passo que quando vamos setar um **aesthetic** como constante, o valor é passado fora de `aes()`.

Vejamos os exemplos anteriores com um _aesthetic_ constante para cor e shape:

```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL))+
  geom_point(color = "red")
```



```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL))+
  geom_point(shape = 2)
```

Note que devemos passar as constantes para `geom_point()` (fora de `aes()`) - o elemento de objetos geométricos - e não para `ggplot()`.

Veja quantos _shapes_ podemos *usar* no **R**:

```{r, fig.align="center"}
d=data.frame(p=c(0:25,32:127))
ggplot() +
  scale_y_continuous(name="") +
  scale_x_continuous(name="") +
  scale_shape_identity() +
  geom_point(data=d, mapping=aes(x=p%%16, y=p%/%16, shape=p), size=5, fill="red") +
  geom_text(data=d, mapping=aes(x=p%%16, y=p%/%16+0.25, label=p), size=3)
# http://sape.inf.usi.ch/quick-reference/ggplot2/shape
```

Cuidado ao setar uma _aesthetic_ como constante dentro de `aes()`, pois isso pode resultar em um comportamento inesperado.

```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot(mapping = aes(x=VOLUME, y=PRECO_TOTAL)) +
  geom_point(aes(color = "green"))
```

Embora tenhámos setado a cor como `"green"`, o fato de termos feito dentro de `aes()` faz com que o `ggplot`

### Geoms

**Geoms** são as formas geométricas a serem plotadas nos gráficos, exemplo `geom_line()`, `geom_col()`, `geom_point()`, etc. Eles diferem de um para o outro nos tipos de _aesthetics_ que eles _requerem_ ou _entendem_. Por exemplo: `geom_point()` requer aes(x, y), ao passo que `geom_bar()` requer aes(x) apenas.

Para obter ajuda digite `?geom_x`.

### Exemplos para _Geoms_

**_geoms_ para uma variável numérica (contínua de preferência)**

```{r, fig.align="center"}
c <- tb_ibama2 %>%
  ggplot(mapping = aes(x=quant_sim))
```

**DICA:** Note que podemos atribuir o resultado do gráfico a um objeto no R e acrescentar outras _layers_ posteriormente.


```{r, fig.align="center"}
c + geom_density()
c + geom_histogram()
```

**_geoms_ para uma variável numérica discreta**

```{r, fig.align="center"}
# contagem
tb_ibama2 %>%
  ggplot(mapping = aes(x=TIPO_GF))+
  geom_bar()
```

**_geoms_ para duas variáveis (contínuas)**

`geom_point()` tambpem pode ser usado neste caso:

```{r, fig.align="center"}
e <- tb_ibama2 %>%
  ggplot(mapping=aes(x=VOLUME, y=PRECO_TOTAL))
e + geom_point()
```

**_geoms_ para duas variáveis (uma discreta e uma contínua)**


```{r, fig.align="center"}
f <- tb_ibama2 %>%
  ggplot(mapping=aes(TIPO_GF, quant_sim))
f + geom_boxplot()
f + geom_violin()
```

**_geoms_ para gráficos de linha**

Neste ponto, vamos trocar de _dataset_. Passaremos a utilizar agora o dataset `tb_censo_escolar`. Faremos algumas transformações com `dplyr` e seguiremos direto para o plot usando pipe `%>%`.

```{r, fig.align="center"}
tb_censo_escolar %>%
  group_by(SG_UF, NU_ANO_CENSO) %>%
  summarise(QTD_TOTAL = sum(QTD_ALUNOS, na.rm = TRUE)) %>%
  ggplot(mapping=aes(NU_ANO_CENSO, QTD_TOTAL, colour=SG_UF))+
  geom_line()
```

No caso de gráficos de linhas, ao invés usar cores diferentes, poderíamos ainda alterar o tipo de linha conforme as categorias de uma 3ª variável, por meio do argumento `linetype`:

```{r, fig.align="center"}
tb_censo_escolar %>%
  group_by(SG_UF, NU_ANO_CENSO) %>%
  summarise(QTD_TOTAL = sum(QTD_ALUNOS, na.rm = TRUE)) %>%
  ggplot(mapping=aes(NU_ANO_CENSO, QTD_TOTAL, linetype=SG_UF))+
  geom_line()
```

**DICA:** Há também outros _geoms_ que você encontrará na página de ajuda.


### Positions

Um aspecto dos gráficos de `ggplot2` que não chega a ser uma _layer_, mas que será importante de observarmos diz respeito a ajustes de posição. Elas serão muito importantes para gráficos de de barras com duas variáveis.

Os ajustes de posição definirão como os _geoms_ se localizam no gráfico, de modo que não ocupem o mesmo espaço. No exemplo do gráfico de barras, podemos fazer gráficos de barras justapostas ou empilhadas.

-`position="stacked` é o ajuste padrão de `geom_point()`. Ela coloca cada objeto na posição exata do contexto do gráfico. No caso de gráficos de barras, teríamos barras acumuladas (_stacked_):

```{r, fig.align="center"}
# tb_censo_escolar %>%
#   ggplot(mapping=aes(x=SG_UF, fill=factor(CO_ETAPA_ENSINO)))+
#   geom_bar(position="stack")
# precisa passar CO_ETAPA_ENSINO como factor, senao ele lê como numerica
tb_censo_escolar %>%
  ggplot(mapping=aes(x=SG_UF, fill=factor(NU_ANO_CENSO)))+
  geom_bar(position="stack") # ou simplemente geom_bar()
```

**DICA:** Note que _forçamos_ a variável _NU_ANO_CENSO_ como um _factor_, para que o R a trate como uma variável categórica e não como uma data para realizar a plotagem. Um _factor_ é uma abstração que o R faz para armazenas variáveis categóricas de mod mais eficiente na memória do computador. Para cada valor ele cria um _level_ numérico. É muito mais eficiente guardar um número do que um nome ou uma data, por exemplo.

- **position = "dodge"** coloca objetos sobrepostos um ao lado de outro. Nesse caso, teremos barras justapostas:

```{r, fig.align="center"}
gg_barras <- tb_censo_escolar %>%
  ggplot(mapping=aes(x=SG_UF, fill=factor(NU_ANO_CENSO)))+
  geom_bar(position="dodge")
```

**DICA:** Se voce quiser inverter as coordenadas do gráfico, pode fazer isso trocando os parâmetros `x` e `y` e em `aes()`, ou utilizando a função `coord_flip()`:

```{r, fig.align="center"}
gg_barras + coord_flip()
```

- **position="fill"** também empilhará os elementos, mas irá normalizar a altura de todas as barras para que fiquem na mesma escala. Isso torna mais fácil comparar as proporções entre os grupos:

```{r, fig.align="center"}
tb_censo_escolar %>%
  ggplot(mapping=aes(x=SG_UF, fill=factor(NU_ANO_CENSO)))+
  geom_bar(position="fill")
```


- **position="jitter"** é útil para gráficos de dispersão, pois hpa um problema muito comum neste tipo de gráfico que é a sobreposição de pontos (*overplotting*). Com *jitter*, *ggplot2* adiciona um ruído aleatório nas posições de X e Y para que eles não se sobreponham:

```{r, fig.align="center", fig.height=2, fig.width=3, warning=TRUE}
# mpg %>%
#   ggplot(mapping=aes(x=displ, y=hwy))+
#            geom_point(position="jitter")
```
Há outros ajustes de posição bem úteis, como:

- **position="nudge"** afasta os rótulos dos pontos;
- **position="identity"** sobrepõe os elementos uns sobre os outros.

## Facetting

As **facetts** em `ggplot2` nos permitem criar vários gráficos com base em subconjuntos de dados e plotá-los numma mesma área. É uma técnica muito útil (quando temos variáveis categóricas) e desejamos visualizar o comportamento de diferentes categorias num mesmo gráfico.

Há duas funções que permitem criar facetas: `facet_wrap()` e `facet_grid()`.

Tanto **facet_wrap** quanto **facet_grid** permitem a divisão do plot da(s) variável(is) passadas em `aes()` de acordo com as categorias de uma 3ª ou 3ª e 4ª variáveis.

Voltaremos aos exemplos com a base modificada do IBAMA `tb_ibama2`. Usaremos o log do volume apenas para que os valores dos eixos não se sobreponham. Embora seja possível ajustar isso com as funções de `ggplot2`, por uma questão de priorização e espaço optamos por não abordar essa funcionalidade nesta apostila.

```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot()+
  geom_point(mapping=aes(x=log(VOLUME), y=PRECO_TOTAL))+
  facet_wrap(TIPO_GF ~ UF_DESTINATÁRIO, nrow = 4)
```

Note acima que podemos definir o número de linhas desejado para plotagem com o argumento `nrow` ou o número de colunas com `ncol` e automaticamente o outro argumento será determinado. O símbolo `~` é muito utilizado no **R**. Nesse casos significa as variáveis de `aes()` serão plotadas em função das variáveis `STATUS_GF` e `TIPO_DESTINO`, ou seja, para cada combinação das categorias destas variáveis, será feito um plot com as variáveis passadas em `aes()`. Note que o arranjo das combinações das categorias `STATUS_GF` e `TIPO_DESTINO` são passadas nas colunas de gráficos, como se fossem os títulos de cada plot específico.

No caso de `facet_grid()`, a organização do _output_ será um pouco diferente. Será feito, como o próprio nome da função diz, um _grid_. Onde as linhas dirão respetio a uma das variáveis e a coluna à outra variável. É como se fosse um jogo de batalha naval, é uma matriz de pequenos gráficos. Como resultado, você verá que há cruzamentos entre as variáveis _TIPO_DESTINO_ e _STATUS_GF_ que resultam em um gráfico vazio por ausência de dados que estejam naquelas respectivas categorias das duas variáveis. No caso anterior, com `facte_wrap()` isso não ocorre.


```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot()+
  geom_point(mapping=aes(x=log(VOLUME), y=PRECO_TOTAL))+
  facet_grid(TIPO_GF ~ UF_DESTINATÁRIO)
```



## Títulos, rótulos, temas e legendas

USAR R4DS (para o Markdown tb)


Há duas formas de alterar títulos e rótulos dos eixos em `ggplot2`. Você pode optar por `ggtitle("título do gráfico")`, `xlab("rótulo eixo x")`, `ylab("rótulo eixo y")`. Ou então, pode usar `labs()`. No caso, de usar labs, você pode alterar todos esses campos e outros, como o de legenda dentro da mesma função.

Note, no entanto, que o parâmetro que controla o título da legenda muda dependendo do parâmetro dentro de `mapping = aes()` a partir do qual a legenda foi gerada. Normalmente, a legenda é gerada ou pelos parâmetros `colour`, `fill`, `size`, `shape`, `linetype` e `alpha`. Esses mesmos parâmetros, dependendo do caso, deverão ser passados dentro da função `labs()` para controlar o título da legenda, como por exemplo: `labs(..., shape = "Título da legenda")`.


```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot()+
  geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL, colour=TIPO_GF))+
  labs(title="Título do gráfico",
       x = "Rótulo eixo x",
       y = "Rótulo eixo y",
       colour = "Título da Legenda")
# OU
# tb_ibama2 %>%
#   ggplot()+
#   geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL, colour=TIPO_GF))+
#   ggtitle("Título do gráfico")+
#   xlab("Rótulo eixo x")+
#   ylab("Rótulo eixo y")+
#   labs(colour="Título da legenda")
```


Há ainda funções específicas que também controlam o nome da legenda dependendo do argumento utilizado para gerar a legenda dentro de `aes()` e também a partir de qual tipo de dados, se contínuos ou discretos. Temos os seguintes casos:

* `scale_GERADOR_discrete(name="título da legenda")`

* `scale_GERADOR_continuous(name="título da legenda")`

Dessa forma, temos: `scale_fill_discrete(name="título da legenda")`, `scale_fill_continuous(name="título da legenda")`, `scale_colour_discrete(name="título da legenda")`, `scale_colour_continuous(name="título da legenda")`, e assim por diante para os demais argumentos geradores da legenda, como `size`, `linetype`, `alpha` e `shape`.

```{r, fig.align="center"}
tb_censo_escolar %>%
  group_by(SG_UF, NU_ANO_CENSO) %>%
  summarise(QTD_TOTAL = sum(QTD_ALUNOS, na.rm = TRUE)) %>%
  ggplot(mapping=aes(NU_ANO_CENSO, QTD_TOTAL, linetype=SG_UF))+
  geom_line()+
  scale_linetype_discrete(name="UF")
```

Podemos inclusive ter mais de um argumento de _mapping_ dentro de `aes()` e podemos controlar as legendas de cada um, adicionando mais uma camada ao gráfico:

```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot()+
  geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL,
                         size=preco_unidade,
                         colour=TIPO_GF))+
  ggtitle("Produção madeireira - Dados IBAMA")+
  xlab("Volume toras")+
  ylab("Preço Total toras")+
  scale_size_continuous(name="Preço por unidade de volume")+
  scale_colour_discrete(name="Grupo")
```



## Alterar cores e paleta de cores

Você deve ter notado, que na maioria dos gráficos, o `ggplot2` utiliza cores padrão da biblioteca para as plotagens. Se você não estiver contente com a paleta de cores padrão utilizada pelo pacote no _mapping_ de suas variáveis, você pode definir manualmente esses cores utilizando uma outra paleta ou outras cores de sua preferência.

O modo de alterar a paleta de cores utilizadas em um argumento de _mapping_ dentro de `aes()` é por meio de funções do tipo `scale_GERADOR_manual()`, alterando-se o parâmetro `values`.

```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot()+
  geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL,
                         size=preco_unidade,
                         colour=TIPO_GF))+
  ggtitle("Produção madeireira - Dados IBAMA")+
  xlab("Volume toras")+
  ylab("Preço Total toras")+
  scale_size_continuous(name="Preço por unidade de volume")+
  scale_colour_manual(values=c("red", "blue", "green", "orange", "yellow"))
```


Por meio dessas mesmas funções do tipo de funções do tipo `scale_GERADOR_manual()`, podemos alterar também os rótulos das categorias exibidas na legenda utilizando o argumento `labels`.

```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot()+
  geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL,
                         size=preco_unidade,
                         colour=TIPO_GF))+
  ggtitle("Produção madeireira - Dados IBAMA")+
  xlab("Volume toras")+
  ylab("Preço Total toras")+
  scale_size_continuous(name="Preço por unidade de volume")+
  scale_colour_manual(values=c("red", "blue", "green", "orange", "yellow"),
                      labels=c("tipo1", "tipo2", "tipo3", "tipo4", "tipo5"))
```

Como menicionamos várias vezes atpe este ponto do curso, no **R** existem várias formas de fazer uma mesma coisa. As funções do tipo `scale_GERADOR_manual()` também permite alterar o título da legenda com o argumento `name`:

```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot()+
  geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL,
                         size=preco_unidade,
                         colour=TIPO_GF))+
  ggtitle("Produção madeireira - Dados IBAMA")+
  xlab("Volume toras")+
  ylab("Preço Total toras")+
  scale_size_continuous(name="Preço por unidade de volume")+
  scale_colour_manual(values=c("red", "blue", "green", "orange", "yellow"),
                      labels=c("tipo1", "tipo2", "tipo3", "tipo4", "tipo5"),
                      name="Grupo")
```

## Área de Plotagem e Tema

Como já afirmamos antes, com `ggplot2` é possível modificar praticamente todos os parâmetros do seu gráfico. E normalmente há mais de uma forma para se fazer cada uma das alterações. Com a função `theme()`, é possível controlar desde o tamanho dos elementos do de plotagem do gráfico, passando pelo tamnho do texto dos rótulos e indo até o tamanho dos quadrados ou "bolinhas" da legenda. No entanto, esta será uma pesquisa a ser feita por você.

Nesta seção traremos apenas algumas funções do `ggplot2` que trazem alguns temas pré-formatados:

* `theme_gray()`: plano de fundo cinza e linhas de grid brancas. É como se trouxesse os dados para frente para facilitar comparações;

* `theme_bw()`: plano de fundo branco e linhas de grid cinzas. Recomendado para apresentações utilizando projetor;

* `theme_linedraw()`: plano de fundo branco e linhas de grid com largura diferenciada.

* `theme_light()`: linhas de grid cor cinza claro e com presença de eixos. Parecido como `theme_linedraw()`;

* `theme_dark()`: igual ao `theme_light()` mas com plano de fundo escuro. Faz linhas coloridas finas se destacarem;

* `theme_minimal()`: tema minimalista sem plano de fundo;

* `theme_classic()`: tema clássico sem linhas de grid;

* `theme_void()`: tema vazio, sem cores de fundo e grid. Recomendado para plots de coordenadas não-usuais ou para desenhos.


```{r, fig.align="center"}
tb_ibama2 %>%
  ggplot()+
  geom_point(mapping=aes(x=VOLUME, y=PRECO_TOTAL, colour=TIPO_GF))+
  labs(title="Título do gráfico", x = "Rótulo eixo x", y = "Rótulo eixo y", colour = "Título da Legenda")+
  theme_bw()
```


**DICA:** Estranhamente, `ggplot2` alinha o título do gráfico sempre à esquerda. Você pode centralizar o título usando justamente a função `theme()`, que comentamos mais acima, escrevendo `theme(plot.title = element_text(hjust=0.5)`. `0.5` indica que o título deve ficar no meio do gráfico, conforme alinhamento horizontal especificado (parâmetro `hjust`). `element_text()` é uma _helper function_ que serve para controlar aspectos textuais como tamanho (`size`) e outros parâmetros como o próprio alinhamento horizontal.

***

## Referências da seção

- _Ggplot themes gallery_. (2020). DATANOVIA website. URL [https://www.datanovia.com/en/blog/ggplot-themes-gallery/](https://www.datanovia.com/en/blog/ggplot-themes-gallery/)

- Lin, A. _Introduction to ggplot2_. Slides. IDRE Statistical Consulting Group. URL [https://stats.idre.ucla.edu/stat/data/intro_ggplot2_int/ggplot2_intro_interactive.html#(1)](https://stats.idre.ucla.edu/stat/data/intro_ggplot2_int/ggplot2_intro_interactive.html#(1))

- Lopes, J. G. (2019). _O guia do ggplot2: como fazer qualquer tipo de gráfico no R_. Blog: Explorando o Universo da Ciência de Dados. 05, 2017. URL [http://joseguilhermelopes.com.br/o-guia-do-ggplot2-como-fazer-qualquer-tipo-de-grafico-no-r/](http://joseguilhermelopes.com.br/o-guia-do-ggplot2-como-fazer-qualquer-tipo-de-grafico-no-r/)

- Wickham, H.; Grolemund, G. (2016). _R for Data Science: Import, Tidy, Transform, Visualize, and Model Data_. O'Reilly Media. december 2016. 522 pages. Disponível em: [https://www.r4ds.co.nz](https://www.r4ds.co.nz).

- Wickham, H. (2016). _ggplot2: Elegant Graphics for Data Analysis_. Springer-Verlag New York. 2016. URL [https://ggplot2.tidyverse.org](https://ggplot2.tidyverse.org)


## Exercícios

1) Escolha uma base que você tenha utilizado recentemente no trabalho e a partir da qual você tenha gerado algum gráfico no excel ou outro software. Tente reproduzir dois ou três gráficos utilizando o pacote `ggplot2`. Não se esqueça de procurar ajuda na internet, principalmente no _Stack Overflow_ e na documentação do pacote, além da apostila.

2) Nos gráficos do exercício 1, há algum aspecto que você gostaria de melhorar? Pesquise sobre como fazê-lo utilizando `ggplot2`.

3) Sofistique seu gráfico do `ggplot2` pro meio da função `ggplotly(objeto_criado_com_ggplot2)` do pacote `plotly`. Você pode tornar o seu gráfico interativo e também construir outros gráficos diferentes com `plotly`.
